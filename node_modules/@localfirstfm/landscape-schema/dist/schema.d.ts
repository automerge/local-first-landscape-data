import { Schema } from 'effect';
export declare const DataWithComment: <A, I>(_dataSchema: Schema.Schema<A, I>) => Schema.Struct<{
    data: Schema.Schema<A, I, never>;
    comment: Schema.optional<typeof Schema.String>;
}>;
export type DataWithComment<A, I = A> = ReturnType<typeof DataWithComment<A, I>>['Type'];
export declare const AppTarget: Schema.Struct<{
    Platform: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ("Browser" | "Node" | "iOS" | "Android" | "macOS" | "WASM" | "Linux" | (string & Record<never, never>))[], readonly ("Browser" | "Node" | "iOS" | "Android" | "macOS" | "WASM" | "Linux" | (string & Record<never, never>))[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    LanguageSDK: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "TypeScript" | "JavaScript" | "Swift" | "Kotlin" | "C#" | "Rust" | "Java" | "Python")[], readonly ((string & Record<never, never>) | "TypeScript" | "JavaScript" | "Swift" | "Kotlin" | "C#" | "Rust" | "Java" | "Python")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    FrameworkIntegrations: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "React" | "Vue" | "Svelte" | "React Native" | "Flutter" | "SwiftUI" | "Zustand" | "Jetpack Compose")[], readonly ((string & Record<never, never>) | "React" | "Vue" | "Svelte" | "React Native" | "Flutter" | "SwiftUI" | "Zustand" | "Jetpack Compose")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    ClientBundleSize: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const Networking: Schema.Struct<{
    Protocol: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "WebSockets" | "HTTP" | "SSE" | "WiFi LAN" | "Bluetooth" | "P2P WiFi" | "TCP" | "Quic")[], readonly ((string & Record<never, never>) | "WebSockets" | "HTTP" | "SSE" | "WiFi LAN" | "Bluetooth" | "P2P WiFi" | "TCP" | "Quic")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Topology: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "P2P" | "P2P via Relay Servers" | "Client-Server", (string & Record<never, never>) | "P2P" | "P2P via Relay Servers" | "Client-Server", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const ServerSideData: Schema.Struct<{
    PersistenceMechanism: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "S3 (or compatible)" | "Postgres" | "MongoDB" | "MySQL" | "SQLite" | "Custom" | "N/A" | "Cloudflare Durable Object Storage")[], readonly ((string & Record<never, never>) | "S3 (or compatible)" | "Postgres" | "MongoDB" | "MySQL" | "SQLite" | "Custom" | "N/A" | "Cloudflare Durable Object Storage")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    DataSize: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "100MB" | "1GB" | "10GB" | "100GB" | "1TB" | "10TB" | "100TB" | "1PB" | "10PB" | "100PB", (string & Record<never, never>) | "100MB" | "1GB" | "10GB" | "100GB" | "1TB" | "10TB" | "100TB" | "1PB" | "10PB" | "100PB", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    DataModelParadigm: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Relational" | "Document", (string & Record<never, never>) | "Relational" | "Document", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    SchemaManagement: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "Schema definition" | "Validate schemas on write" | "Schema migrations")[], readonly ((string & Record<never, never>) | "Schema definition" | "Validate schemas on write" | "Schema migrations")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    ExistingDatabaseSupport: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const ClientSideData: Schema.Struct<{
    QueryAPI: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "Async" | "Sync" | "Signals-based Reactivity" | "Reactive queries")[], readonly ((string & Record<never, never>) | "Async" | "Sync" | "Signals-based Reactivity" | "Reactive queries")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    LocalRefreshLatency: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", (string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    PersistenceMechanism: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "SQLite" | "Custom" | "IndexedDB" | "PGLite via OPFS" | "Yjs" | "LevelDB" | "RocksDB")[], readonly ((string & Record<never, never>) | "SQLite" | "Custom" | "IndexedDB" | "PGLite via OPFS" | "Yjs" | "LevelDB" | "RocksDB")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    PersistenceFeatures: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Full-text search" | "Indexes" | "Transactions", (string & Record<never, never>) | "Full-text search" | "Indexes" | "Transactions", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    DataModel: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Relational" | "Document", (string & Record<never, never>) | "Relational" | "Document", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    SchemaManagement: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "Schema definition" | "Schema migrations" | "Schema validation on write")[], readonly ((string & Record<never, never>) | "Schema definition" | "Schema migrations" | "Schema validation on write")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    OfflineReads: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Full Support" | "Query Cache" | "No Support", (string & Record<never, never>) | "Full Support" | "Query Cache" | "No Support", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    OptimisticUpdates: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    OfflineWrites: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Local conflict resolution" | "Cached offline writes" | "No support", (string & Record<never, never>) | "Local conflict resolution" | "Cached offline writes" | "No support", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    DataSize: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const SynchronizationStrategy: Schema.Struct<{
    FullOrPartialReplication: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "Full Replication" | "Partial Replication")[], readonly ((string & Record<never, never>) | "Full Replication" | "Partial Replication")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    ConflictHandling: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Automatic via CRDT" | "Rebase via mutations" | "Server reconciliation" | "No Support (Implicit LWW)" | "Custom conflict resolution supported", (string & Record<never, never>) | "Automatic via CRDT" | "Rebase via mutations" | "Server reconciliation" | "No Support (Implicit LWW)" | "Custom conflict resolution supported", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    WhereResolutionOccurs: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Server" | "Client", (string & Record<never, never>) | "Server" | "Client", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    WhatGetsSynced: Schema.optional<Schema.Struct<{
        data: Schema.Schema<{
            readonly ClientToServer?: string | undefined;
            readonly ServerToClient?: string | undefined;
            readonly ClientToClient?: string | undefined;
        }, {
            readonly ClientToServer?: string | undefined;
            readonly ServerToClient?: string | undefined;
            readonly ClientToClient?: string | undefined;
        }, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Authority: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Decentralized" | "Centralized", (string & Record<never, never>) | "Decentralized" | "Centralized", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Latency: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", (string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Throughput: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Concurrency: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const AuthIdentity: Schema.Struct<{
    Encryption: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    AuthenticationMethod: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "Tokens" | "Built-in" | "Full Custom" | "JWT Tokens" | "Public keys")[], readonly ((string & Record<never, never>) | "Tokens" | "Built-in" | "Full Custom" | "JWT Tokens" | "Public keys")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    AuthorizationPermissions: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Custom" | "ACLs" | "RBAC", (string & Record<never, never>) | "Custom" | "ACLs" | "RBAC", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const UIRelated: Schema.Struct<{
    RichTextEditing: Schema.optional<Schema.Struct<{
        data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    Components: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly string[], readonly string[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const DevelopmentWorkflowsDX: Schema.Struct<{
    DebuggingTools: Schema.optional<Schema.Struct<{
        data: Schema.Schema<readonly ((string & Record<never, never>) | "DevTools" | "Dashboard" | "Data Inspector" | "Network Inspector")[], readonly ((string & Record<never, never>) | "DevTools" | "Dashboard" | "Data Inspector" | "Network Inspector")[], never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    CLI: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
    TypeSupport: Schema.optional<Schema.Struct<{
        data: Schema.Schema<string, string, never>;
        comment: Schema.optional<typeof Schema.String>;
    }>>;
}>;
export declare const Logo: Schema.Struct<{
    Light: Schema.optional<typeof Schema.String>;
    Dark: Schema.optional<typeof Schema.String>;
}>;
export declare const schemaVersion = 1;
export declare const LandscapeSchema: Schema.Struct<{
    Version: Schema.Literal<[1]>;
    Id: Schema.SchemaClass<string, string, never>;
    Name: Schema.SchemaClass<string, string, never>;
    Description: Schema.optional<Schema.SchemaClass<string, string, never>>;
    MaturityLevel: Schema.optional<Schema.Schema<(string & Record<never, never>) | "Experimental" | "Beta" | "Production-Ready", (string & Record<never, never>) | "Experimental" | "Beta" | "Production-Ready", never>>;
    Logo: Schema.optional<Schema.Struct<{
        Light: Schema.optional<typeof Schema.String>;
        Dark: Schema.optional<typeof Schema.String>;
    }>>;
    Website: Schema.optional<Schema.refine<string, typeof Schema.String>>;
    GitHub: Schema.optional<Schema.refine<string, typeof Schema.String>>;
    GetStarted: Schema.optional<Schema.refine<string, typeof Schema.String>>;
    UniquenessNote: Schema.optional<Schema.SchemaClass<string, string, never>>;
    InitialReleaseDate: Schema.optional<Schema.refine<Date, Schema.Schema<Date, string, never>>>;
    NotableAdopters: Schema.optional<Schema.Array$<Schema.Struct<{
        Name: Schema.SchemaClass<string, string, never>;
        URL: Schema.refine<string, typeof Schema.String>;
    }>>>;
    Deployment: Schema.optional<Schema.Array$<Schema.Schema<(string & Record<never, never>) | "Self-hosted" | "Hosted", (string & Record<never, never>) | "Self-hosted" | "Hosted", never>>>;
    License: Schema.optional<Schema.Schema<(string & Record<never, never>) | "Proprietary" | "MIT" | "GPL" | "Apache" | "FSL-Apach 2.0", (string & Record<never, never>) | "Proprietary" | "MIT" | "GPL" | "Apache" | "FSL-Apach 2.0", never>>;
    AppTarget: Schema.optional<Schema.Struct<{
        Platform: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ("Browser" | "Node" | "iOS" | "Android" | "macOS" | "WASM" | "Linux" | (string & Record<never, never>))[], readonly ("Browser" | "Node" | "iOS" | "Android" | "macOS" | "WASM" | "Linux" | (string & Record<never, never>))[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        LanguageSDK: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "TypeScript" | "JavaScript" | "Swift" | "Kotlin" | "C#" | "Rust" | "Java" | "Python")[], readonly ((string & Record<never, never>) | "TypeScript" | "JavaScript" | "Swift" | "Kotlin" | "C#" | "Rust" | "Java" | "Python")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        FrameworkIntegrations: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "React" | "Vue" | "Svelte" | "React Native" | "Flutter" | "SwiftUI" | "Zustand" | "Jetpack Compose")[], readonly ((string & Record<never, never>) | "React" | "Vue" | "Svelte" | "React Native" | "Flutter" | "SwiftUI" | "Zustand" | "Jetpack Compose")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        ClientBundleSize: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    Networking: Schema.optional<Schema.Struct<{
        Protocol: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "WebSockets" | "HTTP" | "SSE" | "WiFi LAN" | "Bluetooth" | "P2P WiFi" | "TCP" | "Quic")[], readonly ((string & Record<never, never>) | "WebSockets" | "HTTP" | "SSE" | "WiFi LAN" | "Bluetooth" | "P2P WiFi" | "TCP" | "Quic")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Topology: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "P2P" | "P2P via Relay Servers" | "Client-Server", (string & Record<never, never>) | "P2P" | "P2P via Relay Servers" | "Client-Server", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    ServerSideData: Schema.optional<Schema.Struct<{
        PersistenceMechanism: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "S3 (or compatible)" | "Postgres" | "MongoDB" | "MySQL" | "SQLite" | "Custom" | "N/A" | "Cloudflare Durable Object Storage")[], readonly ((string & Record<never, never>) | "S3 (or compatible)" | "Postgres" | "MongoDB" | "MySQL" | "SQLite" | "Custom" | "N/A" | "Cloudflare Durable Object Storage")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        DataSize: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "100MB" | "1GB" | "10GB" | "100GB" | "1TB" | "10TB" | "100TB" | "1PB" | "10PB" | "100PB", (string & Record<never, never>) | "100MB" | "1GB" | "10GB" | "100GB" | "1TB" | "10TB" | "100TB" | "1PB" | "10PB" | "100PB", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        DataModelParadigm: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Relational" | "Document", (string & Record<never, never>) | "Relational" | "Document", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        SchemaManagement: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "Schema definition" | "Validate schemas on write" | "Schema migrations")[], readonly ((string & Record<never, never>) | "Schema definition" | "Validate schemas on write" | "Schema migrations")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        ExistingDatabaseSupport: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    ClientSideData: Schema.optional<Schema.Struct<{
        QueryAPI: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "Async" | "Sync" | "Signals-based Reactivity" | "Reactive queries")[], readonly ((string & Record<never, never>) | "Async" | "Sync" | "Signals-based Reactivity" | "Reactive queries")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        LocalRefreshLatency: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", (string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        PersistenceMechanism: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "SQLite" | "Custom" | "IndexedDB" | "PGLite via OPFS" | "Yjs" | "LevelDB" | "RocksDB")[], readonly ((string & Record<never, never>) | "SQLite" | "Custom" | "IndexedDB" | "PGLite via OPFS" | "Yjs" | "LevelDB" | "RocksDB")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        PersistenceFeatures: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Full-text search" | "Indexes" | "Transactions", (string & Record<never, never>) | "Full-text search" | "Indexes" | "Transactions", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        DataModel: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Relational" | "Document", (string & Record<never, never>) | "Relational" | "Document", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        SchemaManagement: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "Schema definition" | "Schema migrations" | "Schema validation on write")[], readonly ((string & Record<never, never>) | "Schema definition" | "Schema migrations" | "Schema validation on write")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        OfflineReads: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Full Support" | "Query Cache" | "No Support", (string & Record<never, never>) | "Full Support" | "Query Cache" | "No Support", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        OptimisticUpdates: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        OfflineWrites: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Local conflict resolution" | "Cached offline writes" | "No support", (string & Record<never, never>) | "Local conflict resolution" | "Cached offline writes" | "No support", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        DataSize: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    SynchronizationStrategy: Schema.optional<Schema.Struct<{
        FullOrPartialReplication: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "Full Replication" | "Partial Replication")[], readonly ((string & Record<never, never>) | "Full Replication" | "Partial Replication")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        ConflictHandling: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Automatic via CRDT" | "Rebase via mutations" | "Server reconciliation" | "No Support (Implicit LWW)" | "Custom conflict resolution supported", (string & Record<never, never>) | "Automatic via CRDT" | "Rebase via mutations" | "Server reconciliation" | "No Support (Implicit LWW)" | "Custom conflict resolution supported", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        WhereResolutionOccurs: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Server" | "Client", (string & Record<never, never>) | "Server" | "Client", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        WhatGetsSynced: Schema.optional<Schema.Struct<{
            data: Schema.Schema<{
                readonly ClientToServer?: string | undefined;
                readonly ServerToClient?: string | undefined;
                readonly ClientToClient?: string | undefined;
            }, {
                readonly ClientToServer?: string | undefined;
                readonly ServerToClient?: string | undefined;
                readonly ClientToClient?: string | undefined;
            }, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Authority: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Decentralized" | "Centralized", (string & Record<never, never>) | "Decentralized" | "Centralized", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Latency: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", (string & Record<never, never>) | "~1ms" | "~10-100ms" | "~1s" | ">10s", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Throughput: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Concurrency: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    AuthIdentity: Schema.optional<Schema.Struct<{
        Encryption: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        AuthenticationMethod: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "Tokens" | "Built-in" | "Full Custom" | "JWT Tokens" | "Public keys")[], readonly ((string & Record<never, never>) | "Tokens" | "Built-in" | "Full Custom" | "JWT Tokens" | "Public keys")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        AuthorizationPermissions: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Custom" | "ACLs" | "RBAC", (string & Record<never, never>) | "Custom" | "ACLs" | "RBAC", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    UIRelated: Schema.optional<Schema.Struct<{
        RichTextEditing: Schema.optional<Schema.Struct<{
            data: Schema.Schema<(string & Record<never, never>) | "Yes" | "No", (string & Record<never, never>) | "Yes" | "No", never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        Components: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly string[], readonly string[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    DevelopmentWorkflowsDX: Schema.optional<Schema.Struct<{
        DebuggingTools: Schema.optional<Schema.Struct<{
            data: Schema.Schema<readonly ((string & Record<never, never>) | "DevTools" | "Dashboard" | "Data Inspector" | "Network Inspector")[], readonly ((string & Record<never, never>) | "DevTools" | "Dashboard" | "Data Inspector" | "Network Inspector")[], never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        CLI: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
        TypeSupport: Schema.optional<Schema.Struct<{
            data: Schema.Schema<string, string, never>;
            comment: Schema.optional<typeof Schema.String>;
        }>>;
    }>>;
    UserControlDataOwnership: Schema.optional<typeof Schema.String>;
}>;
export type Landscape = typeof LandscapeSchema.Type;
